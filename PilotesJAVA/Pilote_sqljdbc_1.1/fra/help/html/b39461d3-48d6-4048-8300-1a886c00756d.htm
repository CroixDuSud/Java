<html DIR="LTR" xmlns:tool="http://www.microsoft.com/tooltip" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:MSHelp="http://msdn.microsoft.com/mshelp">
  <head>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1252" />
    <META NAME="save" CONTENT="history" />
    <title>Utilisation des types de données avancés</title>
    
    <link rel="stylesheet" type="text/css" href="../local/Classic.css">
      
    </link>
    
    <script src="../local/script_loc.js">
      
    </script>
    <script src="../local/script_main.js">
      
    </script>
  </head>
  <body style="display: none;">
    <!--Topic built:11/3/2006-->
<input type="hidden" id="userDataCache" class="userDataStyle">
    </input>
    <input type="hidden" id="hiddenScrollOffset">
    </input>
    <div id="header">
        <tr>
          <td align="left">
            <span id="headerBold">Utilisation des types de données avancés</span>
          </td>
        </tr>
      </table>
      <IMG id="SeeAlso1" style="display:none; height:0; width:0;" src="../local/SeeAlso1a.gif">
        
      </IMG>
      <IMG id="SeeAlso2" style="display:none; height:0; width:0;" src="../local/SeeAlso1c.gif">
        
      </IMG>
      <IMG id="Filter1" style="display:none; height:0; width:0;" src="../local/Filter1a.gif">
        
      </IMG>
      <IMG id="Filter2" style="display:none; height:0; width:0;" src="../local/Filter1c.gif">
        
      </IMG>
      <span style="display:none" id="languageSpan">
        <h1 class="heading">
          Langage
        </h1>
        <div id="selectLanguage" class="section">
          <div class="languageFilter" id="VisualBasic" onclick="ChangeLanguage(this.id)" onkeypress="ChangeLanguage_CheckKey(this.id)" tabindex="0">
            [Visual Basic]
          </div>
          <div class="languageFilter" id="CSharp" onclick="ChangeLanguage(this.id)" onkeypress="ChangeLanguage_CheckKey(this.id)" tabindex="0">
            [C#]
          </div>
          <div class="languageFilter" id="ManagedCPlusPlus" onclick="ChangeLanguage(this.id)" onkeypress="ChangeLanguage_CheckKey(this.id)" tabindex="0">
            [C++]
          </div>
          <div class="languageFilter" id="JSharp" onclick="ChangeLanguage(this.id)" onkeypress="ChangeLanguage_CheckKey(this.id)" tabindex="0">
            [J#]
          </div>
          <div class="languageFilter" id="JScript" onclick="ChangeLanguage(this.id)" onkeypress="ChangeLanguage_CheckKey(this.id)" tabindex="0">
            [JScript]
          </div>
          <div class="languageFilter" id="all" onclick="ChangeLanguage(this.id)" onkeypress="ChangeLanguage_CheckKey(this.id)" tabindex="0">
            (Afficher tout)
          </div>
        </div>
      </span>
    </div>
    <div id="mainSection">
      <div id="allHistory" class="saveHistory" onsave="saveAll()" onload="loadAll()">
      </div>
      <font color="DarkGray"><!-- [This topic is pre-release documentation and is subject to change in future releases. Blank topics are included as placeholders.]<br/>[Documentation built on 11/3/2006]  --></font><p /><p />
      <div id="introductionSection" class="section">
    <p>Les types de données avancés de JDBC ont été présentés dans l'API principale de JDBC 2.0. Le pilote JDBC de Microsoft de SQL Server 2005 utilise les types de données avancés de JDBC pour convertir les types de données SQL Server en un format compréhensible par le langage de programmation Java.</p>
    <p>Le tableau suivant répertorie les mappages par défaut entre les types de données avancés SQL Server, JDBC et du langage de programmation Java.</p>
    <h2 class="heading"></h2><table cellspacing="0" cellpadding="0" border="1" style="background-color: #CCCCCC;"><tr>
          <th>
            Types SQL Server
          </th>
          <th>
            Types JDBC (java.sql.Types)
          </th>
          <th>
            Types langage Java
          </th>
        </tr><tr>
        <td>
          <p>varbinary(max)</p>
          <p>image</p>
        </td>
        <td>
          <p>LONGVARBINARY</p>
        </td>
        <td>
          <p>byte[] (par défaut), Blob, CharacterStream, BinaryStream, String</p>
        </td>
      </tr><tr>
        <td>
          <p>text</p>
          <p>ntext</p>
          <p>varchar(max)</p>
          <p>nvarchar(max)</p>
        </td>
        <td>
          <p>LONGVARCHAR</p>
        </td>
        <td>
          <p>String (par défaut), Clob, CharacterStream, BinaryStream</p>
        </td>
      </tr><tr>
        <td>
          <p>xml</p>
        </td>
        <td>
          <p>LONGVARCHAR</p>
        </td>
        <td>
          <p>String (par défaut), CharacterStream, Clob, byte[], BinaryStream, Blob</p>
        </td>
      </tr><tr>
        <td>
          <p>udt</p>
        </td>
        <td>
          <p>VARBINARY (taille maximale de 8 000 octets)</p>
        </td>
        <td>
          <p>String (par défaut), byte[], BinaryStream, Object</p>
        </td>
      </tr></table>
    <p>Les sections suivantes proposent des exemples d'utilisation du pilote JDBC et des types de données avancés.</p>
  </div>
      <h1 class="heading">Types de données BLOB et CLOB</h1>
      <div id="sectionSection" class="section">
        <content xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
      <p xmlns="">Le pilote JDBC implémente toutes les méthodes JDBC 3.0 de java.sql.Blob et des interfaces java.sql.Clob. Grâce à ces méthodes, vous pouvez extraire et mettre à jour les colonnes de type text, ntext, xml et image. </p>
      <div style="margin: .5em 1.5em .5em 1.5em" xmlns=""><b>Remarque : </b>
        Les valeurs CLOB peuvent être utilisées avec des types de données SQL Server 2005 de grande valeur. En particulier, les types CLOB peuvent être utilisés avec les types de données varchar(max) et nvarchar(max), et les types BLOB peuvent être utilisés avec les types de données varbinary(max) et xml. <p></p>
      </div>
    </content>
      </div>
      <h1 class="heading">Types de données de grande valeur</h1>
      <div id="sectionSection" class="section">
        <content xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
      <p xmlns="">Dans les versions précédentes de SQL Server, le travail sur des types de données de grande valeur nécessitait un traitement spécial. Les types de données de grande valeur sont ceux qui dépassent la taille maximale de ligne de 8 Ko. SQL Server 2005 propose un spécificateur max pour les types de données varchar, nvarchar et varbinary afin de permettre le stockage des valeurs de 2^31 octets. Les colonnes de tableau et les variables Transact-SQL peuvent spécifier les types de données varchar(max), nvarchar(max) ou varbinary(max).</p>
      <p xmlns="">Les principaux scénarios de travail sur des types de données de grande valeur impliquent l'extraction d'une base de données ou l'ajout à une base de données. Les sections suivantes décrivent les différentes approches de réalisation de ces tâches.</p>
    </content>
        <sections xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
      <h1 class="heading" xmlns="">Extraction de types de données de grande valeur d'une base de données</h1><div id="sectionSection" class="section" xmlns=""><content xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
          <p xmlns="">Lors de l'extraction d'une base de données d'un type de données de grande valeur non binaire, tel que varchar(max), une approche consiste à lire ces données en tant que flux de données de type caractères. Dans l'exemple suivant, la méthode <a href="599cf463-e19f-4baa-bacb-513cad7c6cd8.htm">executeQuery</a> de la classe <a href="ec24963c-8b51-4838-91e9-1fbfa2347451.htm">SQLServerStatement</a> est utilisée pour extraire des données de la base de données et les retourner dans un jeu de résultats. Ensuite, la méthode <a href="c70e210f-0288-47cc-9268-a29c45979729.htm">getCharacterStream</a> de la classe <a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> est utilisée pour lire les données de grande valeur depuis le jeu de résultats.</p>
          <div class="sampleCode" xmlns=""><span codeLanguage="other"><pre>ResultSet rs = stmt.executeQuery("SELECT TOP 1 * FROM Test1");
rs.next();
Reader reader = rs.getCharacterStream(2);</pre></span></div>
          <div style="margin: .5em 1.5em .5em 1.5em" xmlns=""><b>Remarque : </b>
            Cette même approche peut également être utilisée pour les types de données text, ntext et nvarchar(max).<p></p>
          </div>
          <p xmlns="">Lors de l'extraction d'une base de données d'un type de données de grande valeur binaire, tel que varbinary(max), plusieurs approches s'offrent à vous. L'approche la plus efficace consiste à lire les données en tant que flux de données binaire, comme suit :</p>
          <div class="sampleCode" xmlns=""><span codeLanguage="other"><pre>ResultSet rs = stmt.executeQuery("SELECT photo FROM mypics");
Rs.next();
InputStream is = rs.getBinaryStream(2);</pre></span></div>
          <p xmlns="">Vous pouvez également utiliser la méthode <a href="d16a0aea-6144-4fcb-bcbc-5d7daa36d327.htm">getBytes</a> pour lire les données en tant que tableau d'octets, comme suit :</p>
          <div class="sampleCode" xmlns=""><span codeLanguage="other"><pre>ResultSet rs = stmt.executeQuery("SELECT photo FROM mypics");
Rs.next();
byte [] b = rs.getBytes(2);</pre></span></div>
          <div style="margin: .5em 1.5em .5em 1.5em" xmlns=""><b>Remarque : </b>
            Vous pouvez également lire les donnés en tant que BLOB. Cependant, cette méthode est moins efficace que les deux précédentes.<p></p>
          </div>
        </content></div>
      <h1 class="heading" xmlns="">Ajout de types de données de grande valeur à une base de données</h1><div id="sectionSection" class="section" xmlns=""><content xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
          <p xmlns="">Le téléchargement de données de grande valeur avec le pilote JDBC fonctionne correctement dans les cas de correspondance avec la taille de la mémoire ; dans les cas de dépassement de la taille de la mémoire, la transmission de flux de données en continu constitue l'option principale. Cependant, la méthode la plus efficace consiste à télécharger des données de grande valeur via les interfaces de flux.</p>
          <p xmlns="">L'utilisation d'une chaîne ou d'octets est également une option, comme suit :</p>
          <div class="sampleCode" xmlns=""><span codeLanguage="other"><pre>PreparedStatement pstmt = con.prepareStatement("INSERT INTO test1 (c1_id, c2_vcmax) VALUES (?, ?)");
pstmt.setInt(1, 1);
pstmt.setString(2, htmlStr);
pstmt.executeUpdate();</pre></span></div>
          <div style="margin: .5em 1.5em .5em 1.5em" xmlns=""><b>Remarque : </b>
            Cette approche peut également être utilisée pour les valeurs qui sont stockées dans les colonnes text, ntext et nvarchar(max).<p></p>
          </div>
          <p xmlns="">Si vous disposez d'une bibliothèque d'images sur le serveur et que vous devez télécharger des fichiers image binaires dans une colonne varbinary(max), la méthode la plus efficace impliquant le pilote JDBC consiste à utiliser les flux directement, comme suit :</p>
          <div class="sampleCode" xmlns=""><span codeLanguage="other"><pre>Statement stmt = con.createStatement();
PreparedStatement pstmt = con.prepareStatement("INSERT INTO test1 
VALUES( ?, ? )");
FileReader in = new FileReader(new File("CLOBFile20mb.txt");
long len = fileIn.length();
int id = 1;
pstmt.setInt(1,id);
pstmt.setCharacterStream(2, in, (int)len);
pstmt.executeUpdate();
in.close();</pre></span></div>
          <div style="margin: .5em 1.5em .5em 1.5em" xmlns=""><b>Remarque : </b>
            L'utilisation de la méthode CLOB ou BLOB n'est pas efficace pour le téléchargement de données de grande valeur.<p></p>
          </div>
        </content></div>
      <h1 class="heading" xmlns="">Modification de types de données de grande valeur dans une base de données</h1><div id="sectionSection" class="section" xmlns=""><content xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
          <p xmlns="">Dans la plupart des cas, la méthode recommandée pour mettre à jour ou modifier des données de grande valeur dans la base de données consiste à transmettre des paramètres via les classes <a href="a8481c06-fbba-432b-8c69-4f4619c20ad4.htm">SQLServerPreparedStatement</a> et <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a>, à l'aide des commandes Transact-SQL, telles que UPDATE, WRITE et SUBSTRING.</p>
          <p xmlns="">Si vous devez remplacer l'instance d'un mot dans un fichier texte volumineux, tel qu'un fichier HTML archivé, vous pouvez utiliser un objet <b>Clob</b>, comme suit :</p>
          <div class="sampleCode" xmlns=""><span codeLanguage="other"><pre>Statement stmt = con.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM test1");
rs.next();
Clob clob = rs.getClob(2);
long pos = clob.position("dog", 1);
clob.setString(1, "cat", len, 3);
rs.updateClob(2, clob);
rs.updateRow();</pre></span></div>
          <p xmlns="">De plus, vous pouvez effectuer tout le travail sur le serveur et simplement transmettre les paramètres à une instruction UPDATE préparée.</p>
          <p xmlns="">Pour plus d'informations sur les types de données de grande valeur, consultez « Utilisation de types de données de grande valeur » dans la documentation en ligne SQL Server.</p>
        </content></div>
    </sections>
      </div>
      <h1 class="heading">Type de données XML</h1>
      <div id="sectionSection" class="section">
        <content xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
      <p xmlns="">SQL Server 2005 propose un type de données xml qui vous permet de stocker des documents et des fragments XML dans une base de données SQL Server. Le type de données xml est intégré dans SQL Server et est plus ou moins similaire aux autres types intégrés, tels que int et varchar. Comme avec les autres types intégrés, vous pouvez utiliser le type de données xml comme type de colonne lorsque vous créez une table, comme type de variable, type de paramètre, type de retour de fonction ou dans les fonctions CAST et CONVERT Transact-SQL.</p>
      <p xmlns="">Dans le pilote JDBC, le type de données xml peut être mappé en tant que chaîne, tableau d'octets, flux de données, objet CLOB ou BLOB. La chaîne est la représentation par défaut. L'implémentation du type de données xml dans le pilote JDBC offre ce qui suit :</p>
      <ul xmlns=""><li>
          Accès à XML en tant que chaîne standard Java UTF-16 pour les scénarios de programmation les plus courants<br></br>
        </li><li>
          Entrée de XML en UTF-8 ou codé sur 8 bits<br></br>
        </li><li>
          Accès à XML en tant que tableau d'octets avec un BOM de début lors du codage en UTF-16 pour l'échange avec d'autres processeurs XML et fichiers de disque<br></br>
        </li></ul>
      <p xmlns="">SQL Server requiert un BOM de début pour le XML codé en UTF-16. L'application doit proposer cela si les valeurs de paramètre XML sont fournies en tant que tableaux d'octets. SQL Server sort toujours des valeurs XML sous forme de chaînes en UTF-16 sans BOM ni déclaration de codage imbriquée. Lorsque les valeurs XML sont extraites en tant que byte[], BinaryStream ou Blob, un BOM UTF-16 est initialement ajouté à la valeur.</p>
      <div style="margin: .5em 1.5em .5em 1.5em" xmlns=""><b>Remarque : </b>
        Le pilote JDBC ne prend pas en charge la lecture des paramètres de sortie de la procédure stockée du type de données xml. Cependant, il prend en charge l'utilisation du type de données xml en tant que paramètre d'entrée. Si vous devez utiliser le type de données xml en tant que paramètre de sortie, vous devez d'abord convertir le type de données xml en VARCHAR ou LONGVARCHAR dans la procédure stockée avant de pouvoir le lire.<p></p>
      </div>
      <p xmlns="">Pour plus d'informations sur le type de données xml, consultez « Type de données XML » dans la documentation en ligne SQL Server.</p>
    </content>
      </div>
      <h1 class="heading">Type de données défini par l'utilisateur</h1>
      <div id="sectionSection" class="section">
        <content xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5">
      <p xmlns="">L'introduction des types définis par l'utilisateur (User-Defined Types, UDT) dans SQL Server 2005 étend le système de types SQL en vous permettant de stocker des objets et des structures de données personnalisées dans une base de données SQL Server. Les UDT peuvent contenir plusieurs types de données et avoir des comportements, ce qui les différencie des types de données alias traditionnels qui ne comprennent qu'un seul type de données système SQL Server. Les UDT sont définis à l'aide d'un des langages pris en charge par le CLR (Common Language Runtime) Microsoft .NET produisant un code vérifiable. Cela inclut Microsoft Visual C# et Visual Basic .NET. Les données sont considérées comme des champs et des propriétés d'une classe ou structure basée sur .NET Framework, et des comportements sont définis par les méthodes de la classe ou de la structure. </p>
      <p xmlns="">Dans SQL Server 2005, un UDT peut être utilisé en tant que définition de colonne d'une table, variable dans un lot Transact-SQL ou argument d'une fonction Transact-SQL ou d'une procédure stockée.</p>
      <div style="margin: .5em 1.5em .5em 1.5em" xmlns=""><b>Remarque : </b>
        Le pilote JDBC ne prend pas en charge les méthodes getter ou setter pour les méthodes <b>AsciiStream</b> et <b>CharacterStream</b> sur les colonnes UDT. En outre, comme pour le type de données xml, le pilote JDBC ne prend pas en charge la lecture des paramètres de sortie de la procédure stockée du type de données udt. Cependant, il prend en charge l'utilisation du type de données udt en tant que paramètre d'entrée. Si vous devez utiliser le type de données udt en tant que paramètre de sortie, vous devez d'abord convertir le type de données udt en type de données varbinary(max) dans la procédure stockée avant de pouvoir le lire.<p></p>
      </div>
      <p xmlns="">Pour plus d'informations sur les types de données définis par l'utilisateur, voir « Utilisation et modification des instances de types de données définis par l'utilisateur » dans la documentation en ligne SQL Server.</p>
    </content>
      </div>
      <span id="seeAlsoSpan">
        <h1 class="heading">
          Voir aussi
        </h1>
        <div id="seeAlsoSection" class="section">
          <a href="7802328d-4d23-4775-9573-4169b127d258.htm">Types de données du pilote JDBC</a>
        </div>
      </span>
      <!--[if gte IE 5]>
			<tool:tip element="seeAlsoToolTip" avoidmouse="false"/><tool:tip element="languageFilterToolTip" avoidmouse="false"/>
		<![endif]-->
      <div id="footer" class="section">
        <hr /><A NAME="feedback"></A><span id="fb" class="feedbackcss"></span>
		<a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">
			
			© 2006 Microsoft Corporation. Tous droits réservés.
		</a>
 	
      </div>
    </div>
  </body>
</html>